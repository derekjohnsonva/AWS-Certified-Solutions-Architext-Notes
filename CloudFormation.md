---
tags:
  - aws
---

A way to create, update, and delete infrastructure in a consistent way

It can be written using YAML or JSON
Can also be created using [AWS Infrastructure Composer](https://aws.amazon.com/infrastructure-composer/) 

The only section that needs to be in the file is the `Resources` section
The other sections can be in any order.
The one exception to this is that the `AWSTemplateFormatVersion` has to come right before the `Description`

Templates have a `Resources` section that create *Logical Resource*. These are stored in what is referred to as the *Stack*. It is the Stacks job to provision Physical Resources such as [[Elastic Compute Cloud|EC2]] instances.

If a stack is deleted, normally, the physical resources will be deleted as well
## Benefits of CloudFormation
**Infrastructure as code** - No resources are manually created, which is excellent for control. Changes to the infrastructure are reviewed through code.

**Cost** - Each resources within stack is tagged with an identifier so we can easily see how much a stack costs us. We can estimate the costs of our resources using the CloudFormation template.

**Productivity** - Ability to destroy and re-create an infrastructure on the cloud on the fly. We can automate generation of diagrams for our templates.

## Writing a Template
Template Parameters - Accept input from the console/cli/api when the stack is created or updated. Can be reference within Logical Resources

Pseudo Parameters - Variables that are generated by AWS and injected into the template. An example is `AWS::Region`.

These two types of Parameters help to make the template more extensible (i.e. easier to deploy in other regions).

Intrinsic Function - Built in functions that help you manage your stack.
* `Ref` - Gets the physical ID of a logical resource
* `Fn::GetAtt` - Gets attributes of physical resources defined in logical resources
* `Fn::Join` - Joins a list using a delimiter
* `Fn::Split` - Splits a string on a delimiter 
* `Fn::GetAZs` - Get all of the AZs in a region
* `Fn::Select` - Gets an object from a list.
* Conditions (`Fn::If`, and, equals, not, or)
* `Fn::Base64` - Accepts plaintext and outputs Bas64 encoded text
* `Sub` - Lets you replace variables for runtime values. 
* `Fn::Cidr` - Gives you a subnet cider range from a larger cider block
* etc...

**Mappings** - A way to match keys to values to be used in a template. 
	They can have one key or a **Top** and **Second** level key. You can think of it as a hash map of hash maps 
	Commonly used to retrieve AMI for a given region
	Use the `FindInMap` function to get data from the mapping

**Outputs** - Values that will be visible as output when the stack is created 
	This is an optional section
	Can be used in multi-level CloudFormation architectures.
```YAML
Outputs:
	WordpressURL:
		Description: "instance Web URL"
		Value: !Join [ '', ['https://', !GetAtt Instance.DNSName]]
```

Example of a portable template that creates an S3 bucket and an EC2 instance
```yaml
Parameters:
  LatestAmiId:
    Description: "AMI for EC2"
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2'
Resources:
  Bucket:
    Type: 'AWS::S3::Bucket'
  Instance:
    Type: 'AWS::EC2::Instance'
    Properties:
      InstanceType: "t2.micro"
      ImageId: !Ref "LatestAmiId"
```
This is a good template because it uses a parameter for the imageID. It will be different based on where and when it is created.

**`DependsOn`** - Lets you explicitly define a dependency
	CloudFormation tries to do things in parallel. Thus, it has to determine a dependency tree. It does this using functions
	Most of the time you don't need this. CloudFormation will get dependencies right on its own.

CloudFormation Signals
	`cfn-signal` - used to indicate if an EC2 resource has been created successfully. This can be helpful when you need to do a long bootstrapping process for an instance and don't want CFN to say that it is complete until the boostrapping is finished.
	CreationPolicy - Lets you wait until a certain number of signals have been collected to do a task
	WaitCondition - A point that can not be passed until it receives some signal or a timeout has been reached. Uses a WaitHandle to trigger.

`cfn-init` - lets you do desired state configuration. Run once as part of boostrapping
	A line in the Metadata section
	part of user data
`cfn-hup` - a daemon which can be installed 
	it detects change in resource metadata that can update [[Elastic Compute Cloud|EC2]] configuration
##  Using Multiple Stacks
Nested Stacks - allow for a hierarchy of related templates to be combined to form a single product
	Used to reuse resources
	Used to reference other stacks
	Nested stacks should be used when the resources being provisioned share a lifecycle and are related.
	Allow us to overcome 500 resource limit of one stack
A nested stack starts with a **Root** stack and a **Parent** stack. A parent is anything that is not the lowest layer of the stack.
As you create stacks lower in the tree, you need to supply the parameters.
We can use outputs to communicate up the stack tree
We can use **DependsOn** in other stacks
Whole templates can be used in other stacks
**Only use nested stacks when everything is lifecycle linked**

**Cross-Stack References** - Allow one stack to reference another
	Outputs in one stack reference logical resources or attributes in that stack
	They can be exported and then using the `!ImportValue` intrinsic function, referenced from another stack. Exports must have a unique name in the region.
![[Pasted image 20241004181102.png | 500]]
When to use Cross-Stack References - When you need to reference logical resources in another stack.

## StackSets
Used to deploy DFN stacks across many accounts and regions
They are containers in an admin account
contain stack instances which reference stacks (which are in 'target accounts')
Each stack = 1 region in 1 account
StackSets are build using standard templates
![[Pasted image 20241004231907.png | 500]]
Concurrent Accounts = how many accounts can be deployed into at any one time
Failure Tolerance = how many individual deployments can fail before we say the StackSet has failed

Use case
* Enable AWS config and set config rules
* Create IAM Roles
* etc...

## Deletion Policy
if you delete a logical resource from the template, this will by default delete the physical resource. Sometimes this isn't what you want
you can specify **Delete**, **Retain**, or **Snapshot** (on EBS or RDS) as the deletion policy
	snapshots will continue past the stack lifetime.
These policies will only apply to deletes, not to replaces (i.e. changing the resource in the template)

## Stack Roles
Issue: CFN uses the permissions of the logged in identity. This means you need permissions
Fix: Stack Roles let you assume a role for permission. The identity only needs the PassRole.

Basically, a user is given stack permissions but not permissions on the resources the stack points to
## Custom Resources
normally, logical resources tell CFN what physical resources to create
	there are some things that CFN doesn't support
Custom resources give us access to anything that CFN is not currently supporting. They also let us support external resources.
Passes data to something and gets data back from something
![[Pasted image 20241010141659.png]]

